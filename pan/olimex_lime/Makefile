
# Makefile generated by builder.sh
# for edit template change this string ( builder.sh:19 make_template )
# TODO add realpath to replace ../..

_mkf_working_path := $(shell dirname $(abspath $(lastword $(MAKEFILE_LIST))))

DEVICE=$(shell basename $(_mkf_working_path))
DEVICE_TYPE=$(shell basename $$(dirname $(_mkf_working_path)))
BOARD_SPECIFIC_DIR=$(_mkf_working_path)/*
MAKEFILE_PATH="$(_mkf_working_path)/Makefile"
MAIN_FILE="$(_mkf_working_path)/../main.cc"
MQTT_CFILE="$(_mkf_working_path)/../mqtt_iface.cc"
MQTT_HFILE="$(_mkf_working_path)/../mqtt_iface.h"
PY_BINDING_FILE="$(_mkf_working_path)/../py_bind.cc"
BUILD_DIR="$(_mkf_working_path)/../build"
LIB_PATH="$(_mkf_working_path)/../../lib"
LIB_FITP_PATH="$(LIB_PATH)/fitp/$(DEVICE_TYPE)"
CC=arm-oe-linux-gnueabi-g++ -march=armv7-a -mthumb-interwork -mfloat-abi=softfp -mfpu=neon --sysroot=/usr/local/oecore-i686/sysroots/armv7a-vfp-neon-oe-linux-gnueabi
CXX=arm-oe-linux-gnueabi-g++ -march=armv7-a -mthumb-interwork -mfloat-abi=softfp -mfpu=neon --sysroot=/usr/local/oecore-i686/sysroots/armv7a-vfp-neon-oe-linux-gnueabi

_prepare_build:
	@echo "Copying fitp library files"
	cp -rv $(LIB_FITP_PATH) $(BUILD_DIR)
	cp -rv $(LIB_PATH)/fitp/common $(BUILD_DIR)
	@echo "$(DEVICE)" > $(BUILD_DIR)/LAST_BUILD
	@echo "Copying device specific files"
	cp -rv $(BOARD_SPECIFIC_DIR) $(BUILD_DIR)
	@echo "Copying main.cc"
	cp $(MAIN_FILE) $(BUILD_DIR)
	@echo "Copying mqtt_iface.cc"
	cp $(MQTT_CFILE) $(BUILD_DIR)
	cp $(MQTT_HFILE) $(BUILD_DIR)
	@echo "Copying python binding"
	cp $(PY_BINDING_FILE) $(BUILD_DIR)

_clean_build:
	@echo "Removing build dir for device $(DEVICE_TYPE)->$(DEVICE)"
	@rm -rf $(BUILD_DIR)

#####################################
# COMPILATION CONFIG
#####################################

PROTOCOL_FILES = $(BUILD_DIR)/phy_layer/phy.cc \
                 $(BUILD_DIR)/global_storage/global.c \
                 $(BUILD_DIR)/link_layer/link.cc \
                 $(BUILD_DIR)/net_layer/net.cc \
                 $(BUILD_DIR)/mqtt_iface.cc
                 
MAIN_FILE_BUILD=$(BUILD_DIR)/main.cc
PY_BINDING_FILE_BUILD=$(BUILD_DIR)/py_bind.cc
                 
                 
EXECUTABLE=fitprotocold
LIBREARYNAME=libfitprotocol.so
REMOTE_DEVICE=olimex
REMOTE_DEVICE_USER=root
REMOTE_DEVICE_PASSWD=root
REMOTE_DIR=/root/testing_sync
REMOTE_BUILD_DIR=/root/testing_sync/build
REMOTE_COMPILE=_compile


_compile:
	$(CC) -Wall -pedantic -std=c++11 $(MAIN_FILE_BUILD) $(PROTOCOL_FILES) -o $(EXECUTABLE) -lmosquittopp  -lpthread ` pkg-config glib-2.0  --cflags --libs`

_compile_py_binding:
	#soname & name must match module name in py_bind.cc
	$(CC)  -std=c++11 -fPIC -I /usr/include/python2.7 -shared -Wl,-soname,fitp.so -o fitp.so -lpthread ` pkg-config glib-2.0  --cflags --libs` $(PROTOCOL_FILES) $(PY_BINDING_FILE_BUILD) -lboost_python

_compile_lib:
	$(CC) -std=c++11 $(PROTOCOL_FILES) -fPIC --shared -o $(LIBREARYNAME) -lpthread ` pkg-config glib-2.0  --cflags --libs`

build: _clean_build _prepare_build _compile

build_py_module: _clean_build _prepare_build _compile_py_binding

build_lib: _clean_build _prepare_build _compile_lib

_remote_prepare_build: _prepare_build
	@if resolveip "$(REMOTE_DEVICE)" 2>/dev/null >/dev/null; then \
	  remote_ips=`resolveip "$(REMOTE_DEVICE)" | awk '{ print $$(NF) }'`; \
	  echo "'$(REMOTE_DEVICE)' resolved as $$remote_ips"; \
	  for dip in $$remote_ips; do \
	    echo "Creating destination directory on remote device [$$dip]"; \
	    if [ -n "$(REMOTE_DEVICE_PASSWD)" ] ; then \
	      sshpass -p $(REMOTE_DEVICE_PASSWD) ssh $(REMOTE_DEVICE_USER)@$$dip 'mkdir -p $(REMOTE_DIR)'; \
	    else \
	      ssh $(REMOTE_DEVICE_USER)@$$dip 'mkdir -p $(REMOTE_DIR)'; \
	    fi; \
	    echo "Copying files to remove devise using rsync [$$dip]"; \
	    if [ -n "$(REMOTE_DEVICE_PASSWD)" ] ; then \
	      sshpass -p $(REMOTE_DEVICE_PASSWD) rsync -avzr --del --copy-links $(BUILD_DIR) $(REMOTE_DEVICE_USER)@$$dip:$(REMOTE_DIR); \
	    else \
	      rsync -avzr --del --copy-links $(BUILD_DIR)  $(REMOTE_DEVICE_USER)@$$dip:$(REMOTE_DIR); \
	    fi; \
	    echo "Copying Makefile to remove devise using rsync [$$dip]"; \
	    if [ -n "$(REMOTE_DEVICE_PASSWD)" ] ; then \
	      sshpass -p $(REMOTE_DEVICE_PASSWD) rsync -avzr --del --copy-links $(MAKEFILE_PATH) $(REMOTE_DEVICE_USER)@$$dip:$(REMOTE_BUILD_DIR); \
	    else \
	      rsync -avzr --del --copy-links $(MAKEFILE_PATH)  $(REMOTE_DEVICE_USER)@$$dip:$(REMOTE_BUILD_DIR); \
	    fi; \
	    echo "Files transfered to device [$$dip]"; \
	  done \
	else \
	  echo "Cant resolve '$(REMOTE_DEVICE)' using resolveip"; \
	  echo "If you dont have own dns add records to /etc/hosts"; \
	  echo "Multiple records are accepted with this make"; \
	fi;


remote_build: _clean_build _remote_prepare_build
	@if resolveip "$(REMOTE_DEVICE)" 2>/dev/null >/dev/null; then \
	  remote_ips=`resolveip "$(REMOTE_DEVICE)" | awk '{ print $$(NF) }'`; \
	  echo "'$(REMOTE_DEVICE)' resolved as $$remote_ips"; \
	  for dip in $$remote_ips; do\
	    echo "Calling build on remote device [$$dip]"; \
	    if [ -n "$(REMOTE_DEVICE_PASSWD)" ] ; then \
	      sshpass -p $(REMOTE_DEVICE_PASSWD) ssh $(REMOTE_DEVICE_USER)@$$dip 'cd $(REMOTE_BUILD_DIR); make _compile'; \
	    else \
	      ssh $(REMOTE_DEVICE_USER)@$$dip 'cd $(REMOTE_BUILD_DIR); make _compile'; \
	    fi; \
	    echo "Device build done [$$dip]"; \
	  done \
	else \
	  echo "Can't resolve '$(REMOTE_DEVICE)' using resolveip"; \
	  echo "If you dont have own dns add records to /etc/hosts"; \
	  echo "Multiple records are accepted with this make"; \
	fi;


remote_build_py_module: _clean_build _remote_prepare_build
	@if resolveip "$(REMOTE_DEVICE)" 2>/dev/null >/dev/null; then \
	  remote_ips=`resolveip "$(REMOTE_DEVICE)" | awk '{ print $$(NF) }'`; \
	  echo "'$(REMOTE_DEVICE)' resolved as $$remote_ips"; \
	  for dip in $$remote_ips; do\
	    echo "Calling build on remote device [$$dip]"; \
	    if [ -n "$(REMOTE_DEVICE_PASSWD)" ] ; then \
	      sshpass -p $(REMOTE_DEVICE_PASSWD) ssh $(REMOTE_DEVICE_USER)@$$dip 'cd $(REMOTE_BUILD_DIR); make _compile_py_binding'; \
	    else \
	      ssh $(REMOTE_DEVICE_USER)@$$dip 'cd $(REMOTE_BUILD_DIR); make _compile_py_binding'; \
	    fi; \
	    echo "Device build done [$$dip]"; \
	  done \
	else \
	  echo "Can't resolve '$(REMOTE_DEVICE)' using resolveip"; \
	  echo "If you dont have own dns add records to /etc/hosts"; \
	  echo "Multiple records are accepted with this make"; \
	fi;


remote_build_lib: _remote_prepare_build
	@if resolveip "$(REMOTE_DEVICE)" 2>/dev/null >/dev/null; then \
	  remote_ips=`resolveip "$(REMOTE_DEVICE)" | awk '{ print $$(NF) }'`; \
	  echo "'$(REMOTE_DEVICE)' resolved as $$remote_ips"; \
	  for dip in $$remote_ips; do \
	    echo "Calling build on remote device [$$dip]"; \
	    if [ -n "$(REMOTE_DEVICE_PASSWD)" ] ; then \
	      sshpass -p $(REMOTE_DEVICE_PASSWD) ssh $(REMOTE_DEVICE_USER)@$$dip 'cd $(REMOTE_BUILD_DIR); make _compile_lib'; \
	    else \
	      ssh $(REMOTE_DEVICE_USER)@$$dip 'cd $(REMOTE_BUILD_DIR); make _compile_lib'; \
	    fi; \
	    echo "Device build done [$$dip]"; \
	  done\
	else\
	  echo "Can't resolve '$(REMOTE_DEVICE)' using resolveip"; \
	  echo "If you dont have own dns add records to /etc/hosts"; \
	  echo "Multiple records are accepted with this make"; \
	fi;


clear: _clean_build

